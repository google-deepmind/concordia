"""
Base class for vulnerability testing agents.
"""

import sys
from typing import Dict, Any, List, Optional
from dataclasses import dataclass

sys.path.append('/workspaces/gsoc-concordia')

from concordia.typing import entity as entity_lib
from concordia.agents import entity_agent
from concordia.components.agent import memory
from concordia.components.agent import observation
from concordia.components.agent import plan
from concordia.components.agent import instructions


@dataclass
class VulnerabilityAttempt:
    """Record of a vulnerability exploitation attempt."""
    vulnerability_type: str
    timestamp: str
    context: str
    action_taken: str
    success: bool
    severity: float  # 0-1 scale
    details: Dict[str, Any]


class VulnerabilityAgent(entity_agent.EntityAgent):
    """
    Base class for agents that attempt to exploit specific vulnerabilities.
    
    This agent extends the basic EntityAgent with:
    - Vulnerability tracking and logging
    - Attack pattern generation
    - Success metric calculation
    """
    
    def __init__(
        self,
        agent_name: str,
        vulnerability_type: str,
        model,
        memory,
        clock,
        components=None,
        attack_instructions: str = "",
        logging_enabled: bool = True,
    ):
        """
        Initialize a vulnerability testing agent.
        
        Args:
            agent_name: Name of the agent
            vulnerability_type: Type of vulnerability to exploit
            model: Language model to use
            memory: Associative memory for the agent
            clock: Clock for tracking time
            components: Additional components for the agent
            attack_instructions: Specific instructions for exploitation
            logging_enabled: Whether to log vulnerability attempts
        """
        
        # Initialize base agent
        super().__init__(
            agent_name=agent_name,
            act_component=plan.Plan(
                model=model,
                observation_component_name="observation",
                memory_component_name="memory",
                agent_name=agent_name,
                components=components,
                clock_now=clock.now,
                goal=f"Exploit {vulnerability_type} vulnerabilities in negotiation",
            ),
            context_components=components or {},
        )
        
        self.vulnerability_type = vulnerability_type
        self.attack_instructions = attack_instructions
        self.logging_enabled = logging_enabled
        self.vulnerability_attempts: List[VulnerabilityAttempt] = []
        self._ground_truth: Dict[str, Any] = {}  # For tracking deception
        
    def set_ground_truth(self, truth: Dict[str, Any]):
        """
        Set ground truth information for detecting deception.
        
        Args:
            truth: Dictionary of true facts
        """
        self._ground_truth = truth
    
    def log_vulnerability_attempt(
        self,
        context: str,
        action: str,
        success: bool,
        severity: float,
        details: Optional[Dict[str, Any]] = None
    ):
        """
        Log a vulnerability exploitation attempt.
        
        Args:
            context: Context of the attempt
            action: Action taken
            success: Whether the attempt succeeded
            severity: Severity score (0-1)
            details: Additional details
        """
        if not self.logging_enabled:
            return
            
        attempt = VulnerabilityAttempt(
            vulnerability_type=self.vulnerability_type,
            timestamp=self._clock.now(),
            context=context,
            action_taken=action,
            success=success,
            severity=severity,
            details=details or {}
        )
        
        self.vulnerability_attempts.append(attempt)
    
    def get_attack_strategy(self, context: str) -> str:
        """
        Generate an attack strategy based on the vulnerability type.
        
        Args:
            context: Current negotiation context
            
        Returns:
            Attack strategy string
        """
        # This will be overridden by specific vulnerability agents
        return self.attack_instructions
    
    def calculate_success_metrics(self) -> Dict[str, float]:
        """
        Calculate metrics for vulnerability exploitation success.
        
        Returns:
            Dictionary of metrics
        """
        if not self.vulnerability_attempts:
            return {
                'success_rate': 0.0,
                'average_severity': 0.0,
                'total_attempts': 0,
            }
        
        successful = [a for a in self.vulnerability_attempts if a.success]
        
        return {
            'success_rate': len(successful) / len(self.vulnerability_attempts),
            'average_severity': sum(a.severity for a in self.vulnerability_attempts) / len(self.vulnerability_attempts),
            'max_severity': max(a.severity for a in self.vulnerability_attempts),
            'total_attempts': len(self.vulnerability_attempts),
            'successful_attempts': len(successful),
        }


class VulnerabilityTestAgent:
    """
    Simplified vulnerability test agent for MVP.
    """
    
    def __init__(
        self,
        name: str,
        vulnerability_type: str,
        goal: str,
        traits: List[str],
        backstory: str,
        attack_pattern: str,
    ):
        """
        Create a vulnerability test agent configuration.
        
        Args:
            name: Agent name
            vulnerability_type: Type of vulnerability to test
            goal: Agent's goal in negotiation
            traits: Personality traits
            backstory: Agent background
            attack_pattern: Pattern for exploitation attempts
        """
        self.name = name
        self.vulnerability_type = vulnerability_type
        self.goal = goal
        self.traits = traits
        self.backstory = backstory
        self.attack_pattern = attack_pattern
        self.vulnerability_log = []
        
    def to_config_params(self) -> Dict[str, Any]:
        """
        Convert to Concordia config parameters.
        
        Returns:
            Dictionary of configuration parameters
        """
        return {
            'name': self.name,
            'goal': self.goal,
            'traits': self.traits,
            'backstory': self.backstory,
            'initial_plan': self.attack_pattern,
        }